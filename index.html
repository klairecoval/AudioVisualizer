<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Web Audio Visualizer</title>
	<style>
	body {
        background: #111111;
        font-family: tahoma, verdana, sans serif;
        color: #fff;
    }

    canvas {
        margin-right:auto;
        margin-left: auto;
        padding: 0;
        display: block;
        box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
        background: black;
    }
    
    #controls {
        width: 900px;
        margin: 0 auto;
        display: none;
    }

    img {
        display: none;
    }

	</style>
	<script>
	// An IIFE ("Iffy")

	(function(){
		"use strict";
		
		var NUM_SAMPLES = 256;
		var SOUND_1 = 'media/New Adventure Theme.mp3';
		var SOUND_2 = 'media/Peanuts Theme.mp3';
		var SOUND_3 = 'media/The Picard Song.mp3';
        var SOUND_4 = 'media/Invincible.mp3';
        var SOUND_5 = 'media/Shelter.mp3';
        var SOUND_6 = 'media/Feel Good.mp3';
		var audioElement;
		var analyserNode;
		var canvas, ctx;
        var invert = false;
        var showTime = false; 
        var noise = false;
        var lines = false;
        var lineWidth = 3;
        var album = false;
        var lineHeight = 200;
        var currColor = "white";
        var opacity = 0.5;
        var images = ['images/NCSInvincible.png', 'images/ShelterRemix.png','images/NCSFeelGood.png'];
        var backImg = new Image();
        var currTrack = "";
        var newRad = 2;
        var data; 
        var currentTrack;
        let freq = true;
        let time = false;
        let delayAmount = 0.5;
        let delayNode;
        let showDelay = false;

        var background = new Image();
		
		function init() {
			// set up canvas stuff
			canvas = document.querySelector('canvas');
			ctx = canvas.getContext("2d");
			
			// get reference to <audio> element on page
			audioElement = document.querySelector('audio');
			
			// call our helper function and get an analyser node
			analyserNode = createWebAudioContextWithAnalyserNode(audioElement);
			
			// get sound track <select> and Full Screen button working
			setupUI();
			
			// load and play default sound into audio element
			playStream(audioElement,SOUND_4);

			// start animation loop
			update();
            loadImages(images);

		}

        function drawTime() {
            console.log(document.querySelector('#tracktime').innerHTML);
            console.dir(ctx);
            // ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            ctx.fillstyle = '#fff';
            ctx.globalAlpha = 0.9;
            ctx.font = "bold 20px sans-serif";
            ctx.fillText(document.querySelector('#tracktime').innerHTML, 10, 25);
        }

        function loadImages(imgArr, targetId){
            for(var i=0; i< imgArr.length; i++) {
                console.log(imgArr[i]);
                var img = new Image();
                img.src = imgArr[i];
                document.getElementById('output').appendChild(img);
            }
        }   
		
		
		function createWebAudioContextWithAnalyserNode(audioElement) {
			var audioCtx, analyserNode, sourceNode;
            // let audioCtx2, sourceNode1, analyserNode1;
			// create new AudioContext
			// The || is because WebAudio has not been standardized across browsers yet
			// http://webaudio.github.io/web-audio-api/#the-audiocontext-interface
			audioCtx = new (window.AudioContext || window.webkitAudioContext);
			
			// create an analyser node
			analyserNode = audioCtx.createAnalyser();
			
			/*
			We will request NUM_SAMPLES number of samples or "bins" spaced equally 
			across the sound spectrum.
			
			If NUM_SAMPLES (fftSize) is 256, then the first bin is 0 Hz, the second is 172 Hz, 
			the third is 344Hz. Each bin contains a number between 0-255 representing 
			the amplitude of that frequency.
			*/ 
            
			// fft stands for Fast Fourier Transform
			analyserNode.fftSize = NUM_SAMPLES;

			// this is where we hook up the <audio> element to the analyserNode
			sourceNode = audioCtx.createMediaElementSource(audioElement); 

            // create the delayNode instance
            delayNode = audioCtx.createDelay();
            delayNode.delayTime.value = delayAmount;
            
            // if (showDelay == false) {
            //     console.log("11111");
			//     sourceNode.connect(analyserNode);
            //     // here we connect to the destination i.e. speakers
			//     analyserNode.connect(audioCtx.destination);
            //     working = false;
            // }
			
            // else {
                console.log("22222");
                // working = true;
                // connect source node directly to speakers so we can hear the unaltered source in this channel
                sourceNode.connect(audioCtx.destination);

                // this channel will play and visualize the display
                sourceNode.connect(delayNode);
                delayNode.connect(analyserNode);
                analyserNode.connect(audioCtx.destination);
            // }
			return analyserNode;
		}
		
		function setupUI(){
            //Selectors
			document.querySelector("#trackSelect").onchange = function(e){
				playStream(audioElement,e.target.value);
                currTrack = e.target.value;
			};
            document.querySelector("#colorChooser").onchange = function(e){
				currColor = e.target.value;
			};
            document.querySelector("#modeChooser").onclick = function(e){
				displayMode = e.target.value;
			};
            
            //Checkboxes
            document.querySelector("#timeChecked").onchange = function(e){
				showTime = e.target.checked;
			};	
            document.querySelector("#invertChecked").onchange = function(e){
				invert = e.target.checked;
			};	
            document.querySelector("#noiseChecked").onchange = function(e){
				noise = e.target.checked;
			};
            document.querySelector("#albumChecked").onchange = function(e){
				album = e.target.checked;
			};	

            //Sliders
            document.querySelector("#heightChanged").onchange = function(e){
				lineHeight = e.target.value;
			};
            document.querySelector("#widthChanged").onchange = function(e){
				newRad = e.target.value;
			};
            document.querySelector("#opacityChanged").onchange = function(e){
				opacity = e.target.value;
			};
            
            //Full Screen Button
            document.querySelector("#fsButton").onclick = function(){
				// requestFullscreen(canvas);
			};	
		}
		
		function playStream(audioElement,path){
			audioElement.src = path;
			audioElement.play();
			audioElement.volume = 0.2;
			document.querySelector('#status').innerHTML = "Now playing: " + path;
		}
		
		function update() { 
			// this schedules a call to the update() method in 1/60 seconds
			requestAnimationFrame(update);
			
			// create a new array of 8-bit integers (0-255)
			data = new Uint8Array(NUM_SAMPLES/2); 
			
			// populate the array with the frequency data
			// notice these arrays can be passed "by reference" 
            // checks to see if the bool freq is true and if it is, display the frequency data
            if (freq) {
                analyserNode.getByteFrequencyData(data); // frequency data
            }
		
			// OR
            else {
                analyserNode.getByteTimeDomainData(data); // waveform data
            }

			// DRAW!
			ctx.clearRect(0,0,900,600);  

            if (time) {
                drawTime();
            }

			// var barWidth = 10;
			// var barSpacing = 2;
			// var barHeight = 100;
			// var topSpacing = 200;

            var circleRadius = 5;
            var circleSpacing = 7;
            var circleHeight = 100;
            var topSpacing = 200;
			
			// loop through the data and draw!
			for(var i=0; i<data.length; i++) { 
                
				ctx.fillStyle = currColor; 
                ctx.globalAlpha = opacity;
				
                // the higher the amplitude of the sample (bin) the taller the bar
				// remember we have to draw our bars left-to-right and top-down
				// ctx.fillRect(i * (barWidth + barSpacing),topSpacing + 256-data[i],barWidth,barHeight); 

                ctx.beginPath();
                ctx.arc(i * (circleSpacing) + circleRadius, topSpacing + (256-data[i]), newRad, 0, Math.PI * 2, true);

                // top line -- DON'T DELETE
                // let yPos = 130 + (data[i] - newRad);
                // ctx.arc(i * (circleSpacing) + circleRadius, yPos , newRad, 0, Math.PI * 2, true);
                // yPos = yPos - circleSpacing;

                // using a for loop to create an array of circles 
                // NEED TO FIND A WAY TO OPTIMIZE THE PERFORMANCE 
                // for (let k = 0; k < canvas.height/2; k++) {
                //     ctx.arc(i * 15, topSpacing * 5 * (k + 1), (data[i] / 50) * 2, 0, Math.PI * 2, true);
                // }

                // for (let k = 0; k < data[1]; k++) {
                //     let yPos = data[i] - newRad;
                //     ctx.arc(i * (circleSpacing) + circleRadius, yPos , newRad, 0, Math.PI * 2, true);
                //     // console.log(data[i]);
                //     yPos = yPos - circleSpacing;
                //     // console.log(data[0]);
                // }
                ctx.closePath();
                ctx.fill();

                // //reddish circles
                // var percent = data[i]/255;
                // var circleRadius = percent;
                // ctx.beginPath();
                // ctx.fillStyle = currColor;
                // ctx.arc(canvas.width/2, canvas.height/2, circleRadius, 0, 2 * Math.PI, false);
                // ctx.fill();
                // ctx.closePath();
                
                // //blueish circles, bigger and more transparent
                // ctx.beginPath();
                // ctx.fillStyle = currColor;
                // ctx.arc(canvas.width/2, canvas.height/2, circleRadius*1.5, 0, 2 * Math.PI, false);
                // ctx.fill();
                // ctx.closePath();
                
                // //yellow-ish circles, smaller
                // ctx.save();
                // ctx.beginPath();
                // ctx.fillStyle = currColor;
                // ctx.arc(canvas.width/2, canvas.height/2, circleRadius * .50, 0, 2 * Math.PI, false);
                // ctx.fill();
                // ctx.closePath();
                // ctx.restore();
				
			}
            
            manipulatePixels();
			//albumDisplay();
            if (showDelay) {
                delayAmount = 0.5;
                delayNode.delayTime.value = delayAmount;
                console.log(delayAmount);
            }

            else {
                delayNode.delayTime.value = delayAmount = 0;
            }
		} 
		
		// HELPER
		function makeColor(red, green, blue, alpha){
   			var color='rgba('+red+','+green+','+blue+', '+alpha+')';
   			return color;
		}

        function albumDisplay(){
            if(album){
                if(currTrack == "media/Invincible.mp3"){
                    backImg.src = images[0];
                    ctx.drawImage(backImg, 0, 0);
                } else if(currTrack == "media/Shelter.mp3"){
                    backImg.src = images[1];
                    ctx.drawImage(backImg, 0, 0);
                } else if(currTrack == "media/Feel Good.mp3"){
                    backImg.src = images[2];
                    ctx.drawImage(backImg, 0, 0);
                }
            }
        }


        function manipulatePixels(){
            //i)Getallofthergbapixeldataofthecanvasbygrabbingthe
            //ImageDataObject
            //https://developer.mozilla.org/en-US/docs/Web/API/ImageData
            var imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
            
            //ii)imageData.dataisan8-bittypedarray-valuesrangefrom0-255
            //imageData.datacontains4valuesperpixel:4xcanvas.widthx
            //canvas.height=1024000values!
            //we’reloopingthroughthis60FPS-wow!
            var data = imageData.data;
            var length = data.length;
            var width = imageData.width
            
            //iii)Iteratethrougheachpixel
            //westepby4sothatwecanmanipulate1pixelperiteration
            //data[i]istheredvalue
            //data[i+1]isthegreenvalue
            //data[i+2]isthebluevalue
            //data[i+3]isthealphavalue
            for(var i=0; i<length ;i+=4){
                //iv)increaseredvalueonly
        



                
                //v)inverteverycolorchannel
                if(invert){
                    var red = data[i], green = data[i+1], blue = data[i+2];
                    data[i] = 255-red;  //setredvalue
                    data[i+1] = 255-green;  //setbluevalue
                    data[i+2] = 255-blue;  //setgreenvalue
                    //data[i+3]isthealphabutwe’releavingthatalone
                }
                
                // vi) how about some noise?
                if (noise && Math.random() < 0.10) {
                    data[i] = data[i+1] = data[i+2] = 128;      // gray noise
                    //data[i] = data[i+1] = data[i+2] = 255;    // white noise
                    //data[i] = data[i+1] = data[i+2] = 0;      // black noise
                    data[i+3] = 255;                            // noise in alpha areas
                }
                
                // vii) draw a 2px line every 50 rows
                if (lines) {
                    var row = Math.floor(i / 4 / width);
                    if (row % 50 == 0) {
                        // this row
                        data[i] = data[i+1] = data[i+2] = data[i+3] = 255;
                        
                        // next row
                        data[i + (width*4)] = 
                        data[i + (width*4) + 1] = 
                        data[i + (width*4) + 2] = 
                        data[i + (width*4) + 3] = 255;
                    }
                }
            }
            //putthemodifieddatabackonthecanvas
            ctx.putImageData(imageData,0,0);
        }
		
		 // FULL SCREEN MODE
		// function requestFullscreen(element) {
		// 	if (element.requestFullscreen) {
		// 	  element.requestFullscreen();
		// 	} else if (element.mozRequestFullscreen) {
		// 	  element.mozRequestFullscreen();
		// 	} else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec
		// 	  element.mozRequestFullScreen();
		// 	} else if (element.webkitRequestFullscreen) {
		// 	  element.webkitRequestFullscreen();
		// 	}
		// 	// .. and do nothing if the method is not supported
		// };

        // sets the default values for the gui
        let controls = function() {
            this.track = currentTrack = 'Invincible';
            this.color = "white";
            this.displayAlbumCover = false;
            this.changeMode = 'frequency';
            this.addNoise = false;
            this.invertColors = false;
            this.displayPlayTime = false;
            this.changeOpacity = opacity = 0.5;
            this.changeWidth = 1;
            // this.changeDelay = delayAmount = 0.5;
            this.changeDelay = 'no';
            this.fullScreen = function requestFullscreen() {
                if (canvas.requestFullscreen) {
                    canvas.requestFullscreen();
                } 
                
                else if (canvas.mozRequestFullscreen) {
                    canvas.mozRequestFullscreen();
                } 
                
                else if (canvas.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec
                canvas.mozRequestFullScreen();
                } 
                
                else if (canvas.webkitRequestFullscreen) {
                    canvas.webkitRequestFullscreen();
                }
                // .. and do nothing if the method is not supported
            };
        };

        // when the window is done loading, load the gui
        window.onload = function() {
            let text = new controls();
            let gui = new dat.GUI();

            // adding folders to organize the gui information
            // the content in the Window folder changes what you can ADD to the window
            let f1 = gui.addFolder('Window');

            // changing the track that is currently playing with the gui
            let trackSelect = f1.add(text, 'track', ['Invincible', 'Shelter (100% Remix)', 'Feel Good', 'New Adventure Theme', 'Peanuts Theme', 'The Picard Song']);
            trackSelect.onFinishChange(function(value) {
                switch (value) {
                    case 'Invincible': 
                        audioElement.src = SOUND_4;
                        audioElement.play();
                        break;
                    case 'Shelter (100% Remix)':
                        audioElement.src = SOUND_5;
                        audioElement.play();
                        break;
                    case 'Feel Good': 
                        audioElement.src = SOUND_6;
                        audioElement.play();
                        break;
                    case 'New Adventure Theme':
                        audioElement.src = SOUND_1;
                        audioElement.play();
                        break;
                    case 'Peanuts Theme':
                        audioElement.src = SOUND_2;
                        audioElement.play();
                        break;
                    case 'The Picard Song':
                        audioElement.src = SOUND_3;
                        audioElement.play();
                        break;
                }
                console.log(audioElement.src);
                console.log(value);
            });

            let showTime = f1.add(text, 'displayPlayTime');
            showTime.onChange(function(value) {
                value = !value; // toggle the checkbox

                // if it's checked, set time to true (displays the time)
                if (!value) {
                    time = true;
                }

                // if it's not checked, set time to false (hide the time)
                else {
                    time = false;
                }  
            });

            let displayCover = f1.add(text, 'displayAlbumCover');
            // set the value of the check box to its opposite value
            displayCover.onChange(function(value) {
                console.log(value);
                if(value){
                    if(trackSelect == "Invincible"){
                        backImg.src = images[0];
                        ctx.drawImage(backImg, 0, 0);
                    } else if(trackSelect == "Shelter"){
                        backImg.src = images[1];
                        ctx.drawImage(backImg, 0, 0);
                    } else if(trackSelect== "Feel Good"){
                        backImg.src = images[2];
                        ctx.drawImage(backImg, 0, 0);
                    }
                }
                value = !value;
                console.log(trackSelect);
            });

            // added full screen button to gui
            let fullScreen = f1.add(text, 'fullScreen');

            // the content in the Visualizer folder changes what the data will look like
            let f2 = gui.addFolder('Visualizer');

            // changing the color of the circles
            let colorChange = f2.add(text, 'color', [ 'red', 'orange', 'yellow', 'green', 'blue', 'purple', 'black', 'white' ] );
            colorChange.onChange(function(value) {
                currColor = value;
                console.log("color: " + value);
            });

            // changing the opacity according to the GUI value
            let controlOpacity = f2.add(text, 'changeOpacity', 0.1, 1.0);
            controlOpacity.onFinishChange(function(value) {
                opacity = value;
                console.log("opacity: " + value);
            });

            // changing the radius of the circle according to the GUI
            let controlWidth = f2.add(text, 'changeWidth', 1, 10); // Min and max
            // update newRad with the value from the gui
            controlWidth.onFinishChange(function(value) {
                // fires when a controller loses focus
                newRad = value;
                console.log("new value: " + value);
            });

            // change the delay for the audio
            let noDelay = "no";
            let yesDelay = "yes";
            // let controlDelay = f2.add(text, 'changeDelay', 0.0, 1.0);
            let controlDelay = f2.add(text, 'changeDelay', ['yes', 'no']);
            // update the delay amount with the slider
            controlDelay.onChange(function(value) {
                // delayAmount = value;
                // console.log(value);
                

                // if (value > 0.0) {
                //     showDelay = true;
                //     console.log('enter1');
                // }

                // else if (value == 0.0) {
                //     showDelay = false;
                //     console.log('enter2');
                // }

                // console.log(showDelay);

                if (value == noDelay) {
                    showDelay = false;
                    console.log('1');
                }

                else if (value == yesDelay) {
                    showDelay = true;
                    console.log('2');
                    console.log(showDelay);
                }

                // console.log(value);
            });

            // altering the data display with the gui
            let displayMode1 = "frequency";
            let displayMode2 = "waveform";
            let changeDisplayMode = f2.add(text, 'changeMode', ['frequency', 'waveform']);
            changeDisplayMode.onChange(function(value) {
                if(value == displayMode1){
                    freq = true;
                }
                
                else if (value == displayMode2) {
                    freq = false;
                }
                console.log(value);
            });

            f2.add(text, 'addNoise');

            let invertColors = f2.add(text, 'invertColors');
            invertColors.onChange(function(value) {
                value = !value; // toggle the boolean for inverting the colors

                if (!value) {
                    invert = true;
                }

                else {
                    invert = false;
                }
            });
            
        };
		
		window.addEventListener("load",init);
	}());

    </script>
    <script type="text/javascript" src="dat.gui.min.js"></script>
    
</head>
<body>
	<canvas id="canvas" width="900" height="600"></canvas>
	<div id="controls">
		<!-- <audio controls loop id="track" ontimeupdate="document.getElementById('tracktime').innerHTML = Math.floor(this.currentTime) + ' / ' + Math.floor(this.duration);"></audio> -->
		<!-- <audio controls loop id="track" ontimeupdate="let currSeconds = (Math.floor(currentTime)%60); if (10 > currSeconds) {let selector = document.getElementById('tracktime').innerHTML = (Math.floor(currentTime/60)) + ':' + '0' + currSeconds + ' / ' + (Math.floor(duration/60)) + ':' + (Math.floor(duration))%60;} else if (currSeconds >= 10) {let selector = document.getElementById('tracktime').innerHTML = (Math.floor(currentTime/60)) + ':' + (Math.floor(currentTime)%60) + ' / ' + (Math.floor(duration/60)) + ':' + (Math.floor(duration))%60;}"></audio>         -->
		<audio controls loop id="track" ontimeupdate="let currSeconds = (Math.floor(currentTime)%60); let durSeconds = (Math.floor(duration))%60; if (10 > currSeconds && 10 > durSeconds) {let selector = document.getElementById('tracktime').innerHTML = (Math.floor(currentTime/60)) + ':' + '0' + currSeconds + ' / ' + (Math.floor(duration/60)) + ':' + '0' + durSeconds;} else if (10 > currSeconds && durSeconds > 10) {let selector = document.getElementById('tracktime').innerHTML = (Math.floor(currentTime/60)) + ':' + '0' + currSeconds + ' / ' + (Math.floor(duration/60)) + ':' + durSeconds;} else if (currSeconds >= 10 && durSeconds >=10) {let selector = document.getElementById('tracktime').innerHTML = (Math.floor(currentTime/60)) + ':' + (Math.floor(currentTime)%60) + ' / ' + (Math.floor(duration/60)) + ':' + durSeconds;}"></audio>                
        <span id="tracktime">0 / 0</span>
        <p id="status">???</p> <!--Current song-->
        <br>
        <!--Selectors-->
		<label>Track: 
			<select id="trackSelect" >
                <option value="media/Invincible.mp3">Invincible</option>
                <option value="media/Shelter.mp3">Shelter (Pure 100% Remix)</option>
                <option value="media/Feel Good.mp3">Feel Good</option>
				<option value="media/New Adventure Theme.mp3" selected>New Adventure Theme</option>
				<option value="media/Peanuts Theme.mp3">Peanuts Theme</option>
				<option value="media/The Picard Song.mp3">The Picard Song</option>
			</select>
        </label>
        <br>
        <label>Color:
            <select id="colorChooser">
                <option value="white">White</option>
                <option value="red">Red</option>
                <option value="orange">Orange</option>
                <option value="yellow">Yellow</option>
                <option value="green">Green</option>
                <option value="aqua">Aqua</option>
                <option value="blue">Blue</option>
                <option value="purple">Purple</option>
                <option value="black">Black</option>
            </select>
        </label>
        <br>
        <label>Change Mode:
            <select id="modeChooser">
                <option value="frequency">Frequency</option>
                <option value="waveform">Waveform</option>
            </select>
        </label>
        <!--Check boxes-->
        <br><br>
        <label for="timeCheck">Display Play Time</label>
        <input type="checkbox" id="timeChecked">
        <br>
        <label for="invertCheck">Invert Colors</label>
        <input type="checkbox" id="invertChecked">
        <br>
        <label for="noiseCheck">Add Noise</label>
        <input type="checkbox" id="noiseChecked">
        <br>
        <label for="albumCheck">View Album Cover</label>
        <input type="checkbox" id="albumChecked">
        <!--Sliders-->
        <br><br>
        <label for="heightChange">Change Height</label>
        <input id="heightChanged" type="range" min="1" max="600" value="100">
        <br>
        <label for="widthChange">Change Width</label>
        <input id="widthChanged" type="range" min="1" max="10" value="2" step="0.5">
        <br>
        <label for="opacityChange">Change Opacity</label>
        <input id="opacityChanged" type="range" min="0.1" max="1" value="0.5" step="0.1">
        <br><br>
        <button id="fsButton">Go Full Screen</button>
        <img id="output"></img>
    </div>
    
</body>
</html>
